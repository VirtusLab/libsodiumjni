package build

import $packages._

import build.project.settings.{GenerateHeaders, JniModule, JniPublishModule, JniResourcesModule}

import coursier.cache.ArchiveCache
import coursier.util.Artifact
import mill._
import mill.api.BuildCtx
import mill.scalalib._
import mill.scalalib.publish._

import scala.concurrent.duration.Duration
import scala.util.Properties

object libsodiumjni extends MavenModule with JniModule with JniPublishModule with JniResourcesModule
    with GenerateHeaders {
  def ivyDeps = super.ivyDeps() ++ Seq(
    mvn"net.java.dev.jna:jna:5.12.1",
    mvn"net.java.dev.jna:jna-platform:5.12.1"
  )

  def windowsDllName = "libsodiumjni"
  def unixLibName    = "libsodiumjni"

  def unixLinkingLibs = T {
    super.unixLinkingLibs() ++ Seq("sodium")
  }

  private def checkLibraryArchitecture(libPath: os.Path, requiredArch: String): Boolean = {
    if (!Properties.isMac) return true // On Linux, assume compatibility
    if (!os.exists(libPath)) return false

    // Check if library supports the required architecture using lipo or file
    val dylibPath = if (libPath.last.endsWith(".dylib")) libPath
    else libPath / "libsodium.dylib"

    if (!os.exists(dylibPath)) return false

    // Use lipo to check architectures (macOS only)
    val lipoResult = os.proc("lipo", "-info", dylibPath.toString).call(
      cwd = os.pwd,
      check = false,
      stderr = os.Pipe
    )
    if (lipoResult.exitCode == 0) {
      val output = lipoResult.out.trim()
      // Check if it's a universal binary or contains the required architecture
      output.contains(requiredArch) || output.contains("universal")
    }
    else
      // Fallback: if lipo fails, assume it's compatible (might be a symlink or static lib)
      true
  }

  private def unixLibSodiumLibDir(requiredArch: Option[String] = None): Option[String] = {
    // Try pkg-config first
    val pkgConfigResult = os.proc("pkg-config", "--libs", "libsodium").call(
      cwd = os.pwd,
      check = false,
      stderr = os.Pipe
    )
    if (pkgConfigResult.exitCode == 0) {
      val output = pkgConfigResult.out.trim()
      // Extract -L path from pkg-config output (e.g., "-L/opt/homebrew/lib")
      val libPath = output.split(" ").find(_.startsWith("-L")).map(_.drop(2))
      if (libPath.isDefined) {
        val path = os.Path(libPath.get, os.pwd)
        if (os.exists(path))
          // Check architecture compatibility if required
          if (requiredArch.isEmpty || checkLibraryArchitecture(path, requiredArch.get))
            return Some(libPath.get)
      }
      // If pkg-config succeeds but no -L flag, library is in standard path
      // Return None to let the linker find it automatically
      return None
    }
    // Fall back to common installation paths
    // On macOS, prioritize based on architecture: x86_64 -> /usr/local first, arm64 -> /opt/homebrew first
    val commonPaths = if (Properties.isMac && requiredArch.contains("x86_64"))
      Seq(
        "/usr/local/lib",    // macOS Intel Homebrew (for x86_64 on Apple Silicon)
        "/opt/homebrew/lib", // macOS Homebrew (Apple Silicon)
        "/usr/lib"           // Standard macOS path
      )
    else if (Properties.isMac && requiredArch.contains("arm64"))
      Seq(
        "/opt/homebrew/lib", // macOS Homebrew (Apple Silicon)
        "/usr/local/lib",    // macOS Intel Homebrew
        "/usr/lib"           // Standard macOS path
      )
    else
      Seq(
        "/opt/homebrew/lib",         // macOS Homebrew (Apple Silicon)
        "/usr/local/lib",            // macOS/Linux local install
        "/usr/lib/x86_64-linux-gnu", // Ubuntu/Debian 64-bit
        "/usr/lib64",                // Some Linux distributions
        "/usr/lib"                   // Standard Linux path
      )
    for (path <- commonPaths) {
      val libPath = os.Path(path, os.pwd)
      if (os.exists(libPath)) {
        // Check if libsodium exists in this directory
        val sodiumLib = os.list(libPath).find(_.last.startsWith("libsodium"))
        if (sodiumLib.isDefined)
          // Check architecture compatibility if required
          if (requiredArch.isEmpty || checkLibraryArchitecture(libPath, requiredArch.get))
            return Some(path)
      }
    }
    None
  }

  def unixLinkingLibPaths = T {
    val libDir = unixLibSodiumLibDir()
    // If libDir is None, library is in standard path and linker will find it automatically
    super.unixLinkingLibPaths() ++ libDir.toSeq
  }

  private def unixLibSodiumIncludeDir(): String = {
    // Try pkg-config first
    val pkgConfigResult = os.proc("pkg-config", "--cflags", "libsodium").call(
      cwd = os.pwd,
      check = false,
      stderr = os.Pipe
    )
    if (pkgConfigResult.exitCode == 0) {
      val output = pkgConfigResult.out.trim()
      // Extract -I path from pkg-config output (e.g., "-I/opt/homebrew/include")
      val includePath = output.split(" ").find(_.startsWith("-I")).map(_.drop(2))
      if (includePath.isDefined && os.exists(os.Path(includePath.get, os.pwd)))
        return includePath.get
    }
    // Fall back to common installation paths
    val commonPaths = Seq(
      "/opt/homebrew/include", // macOS Homebrew (Apple Silicon)
      "/usr/local/include",    // macOS/Linux local install
      "/usr/include"           // Standard Linux path
    )
    for (path <- commonPaths) {
      val headerPath = os.Path(path, os.pwd) / "sodium.h"
      if (os.exists(headerPath))
        return path
    }
    val osName     = if (Properties.isMac) "macOS" else "Linux"
    val installCmd =
      if (Properties.isMac) "brew install libsodium" else "sudo apt-get install libsodium-dev"
    sys.error(
      s"libsodium headers not found on $osName. Please install libsodium (e.g., '$installCmd')"
    )
  }

  def extraUnixCOptions = T {
    val includeDir = unixLibSodiumIncludeDir()
    Seq(s"-I$includeDir")
  }

  def unixCOptions = T {
    super.unixCOptions() ++ extraUnixCOptions()
  }

  private def windowsLibSodiumDistDir(): os.Path = {
    val archiveCache = ArchiveCache()
    archiveCache.get(
      Artifact("https://download.libsodium.org/libsodium/releases/libsodium-1.0.21-stable-msvc.zip")
    ).unsafeRun()(archiveCache.cache.ec) match {
      case Left(e)     => throw new Exception(e)
      case Right(dir0) => os.Path(dir0, os.pwd)
    }
  }

  def windowsLinkingLibs = T {
    val dir = windowsLibSodiumDistDir()
    val lib = dir / "libsodium" / "x64" / "Release" / "v143" / "dynamic" / "libsodium"
    super.windowsLinkingLibs() ++ Seq(lib.toString)
  }
  def extraWindowsCOptions = T {
    val dir       = windowsLibSodiumDistDir()
    val headerDir = dir / "libsodium" / "include"
    Seq(
      "/D__WIN__",
      "/I",
      headerDir.toString
    )
  }
  def windowsDllCOptions = T {
    super.windowsDllCOptions() ++
      extraWindowsCOptions()
  }
  def windowsLibCOptions = T {
    super.windowsLibCOptions() ++
      extraWindowsCOptions() ++
      Seq("/DSODIUM_STATIC")
  }
  def windowsBatInit = T {
    import java.util.Locale
    val dir            = windowsLibSodiumDistDir()
    val dllDir         = dir / "libsodium" / "x64" / "Release" / "v143" / "dynamic"
    val pathEnvVarName = sys.env.find(_._1.toLowerCase(Locale.ROOT) == "path").fold("PATH")(_._1)
    "@echo on" + System.lineSeparator() +
      super.windowsBatInit() + System.lineSeparator() +
      s"""set "$pathEnvVarName=$dllDir;%$pathEnvVarName%""""
  }

  def jniArtifactDir =
    if (System.getenv("CI") == null) None
    else Some(os.Path("artifacts/", os.pwd))

  def publishVersion = T {
    val wd                                    = BuildCtx.workspaceRoot
    def runGit(args: String*): Option[String] =
      os.proc("git" +: args).call(cwd = wd, check = false, stderr = os.Pipe).out.trim() match {
        case s if s.nonEmpty => Some(s)
        case _               => None
      }
    val lastTag = runGit("describe", "--tags", "--abbrev=0")
      .orElse(runGit("tag", "-l", "--sort=-version:refname").flatMap(s =>
        s.split("\n").headOption.filter(_.nonEmpty)
      ))
    val commitsSince = lastTag.fold(0) { tag =>
      runGit("rev-list", "--count", s"$tag..HEAD").fold(0)(_.toInt)
    }
    if (commitsSince > 0) {
      val versionOrEmpty = lastTag
        .map(_.stripPrefix("v"))
        .map { tag =>
          val idx = tag.lastIndexOf(".")
          if (idx >= 0) tag.take(idx + 1) + (tag.drop(idx + 1).takeWhile(
            _.isDigit
          ).toInt + 1).toString + "-SNAPSHOT"
          else ""
        }
        .getOrElse("0.0.1-SNAPSHOT")
      if (versionOrEmpty.nonEmpty) versionOrEmpty
      else runGit("describe", "--tags", "--always").getOrElse("0.0.1-SNAPSHOT")
    }
    else
      lastTag
        .getOrElse(runGit("describe", "--tags", "--always").getOrElse("0.0.0"))
        .stripPrefix("v")
  }
  def pomSettings = PomSettings(
    description = artifactName(),
    organization = "org.virtuslab.scala-cli",
    url = "https://github.com/virtusLab/libsodiumjni",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github("virtusLab", "libsodiumjni"),
    developers = Seq(
      Developer("alexarchambault", "Alex Archambault", "https://github.com/alexarchambault")
    )
  )

  object test extends libsodiumjni.MavenTests {
    def ivyDeps = super.ivyDeps() ++ Seq(
      mvn"com.novocode:junit-interface:0.11"
    )
    def testFramework = "com.novocode.junit.JUnitFramework"
  }
}

def publishSonatype(tasks: mill.main.Tasks[PublishModule.PublishData]) =
  T.command {
    import scala.concurrent.duration.DurationInt
    val timeout     = 10.minutes
    val credentials = sys.env("SONATYPE_USERNAME") + ":" + sys.env("SONATYPE_PASSWORD")
    val pgpPassword = sys.env("PGP_PASSWORD")
    val data        = T.sequence(tasks.value)()

    doPublishSonatype(
      credentials = credentials,
      pgpPassword = pgpPassword,
      data = data,
      timeout = timeout,
      log = T.ctx().log,
      workspace = BuildCtx.workspaceRoot,
      env = T.env
    )
  }

def doPublishSonatype(
  credentials: String,
  pgpPassword: String,
  data: Seq[PublishModule.PublishData],
  timeout: Duration,
  log: mill.api.Logger,
  workspace: os.Path,
  env: Map[String, String]
): Unit = {

  val artifacts = data.map {
    case PublishModule.PublishData(a, s) =>
      (s.map { case (p, f) => (p.path, f) }, a)
  }

  val isRelease = {
    val versions = artifacts.map(_._2.version).toSet
    val set      = versions.map(!_.endsWith("-SNAPSHOT"))
    assert(
      set.size == 1,
      s"Found both snapshot and non-snapshot versions: ${versions.toVector.sorted.mkString(", ")}"
    )
    set.head
  }
  val publisher = new publish.SonatypePublisher(
    uri = "https://oss.sonatype.org/service/local",
    snapshotUri = "https://oss.sonatype.org/content/repositories/snapshots",
    credentials = credentials,
    signed = true,
    gpgArgs = Seq(
      "--detach-sign",
      "--batch=true",
      "--yes",
      "--pinentry-mode",
      "loopback",
      "--passphrase",
      pgpPassword,
      "--armor",
      "--use-agent"
    ),
    readTimeout = timeout.toMillis.toInt,
    connectTimeout = timeout.toMillis.toInt,
    log = log,
    workspace = workspace,
    env = env,
    awaitTimeout = timeout.toMillis.toInt,
    stagingRelease = isRelease
  )

  publisher.publishAll(isRelease, artifacts: _*)
}
